'use server';

/**
 * @fileOverview A service for interacting with a Pinecone serverless vector store.
 *
 * - upsertVectorStore - Upserts documents into the Pinecone index.
 * - searchVectorStore - Searches the Pinecone index for relevant documents.
 */

import { Pinecone } from '@pinecone-database/pinecone';

const TOP_K = 5; // Number of results to fetch

type Document = {
  role: 'user' | 'bot';
  content: string;
};

// Singleton instance of Pinecone
let pc: Pinecone | null = null;

function getPineconeClient(): Pinecone | null {
  if (!process.env.PINECONE_API_KEY) {
    console.error('PINECONE_API_KEY is not set in environment variables.');
    return null;
  }

  if (!pc) {
    console.log('Initializing Pinecone client for the first time.');
    pc = new Pinecone({ apiKey: process.env.PINECONE_API_KEY });
  }
  return pc;
}

function getPineconeIndex() {
  const pineconeClient = getPineconeClient();
  if (!pineconeClient) return null;

  if (!process.env.PINECONE_INDEX) {
    console.error('PINECONE_INDEX is not set in environment variables.');
    return null;
  }
   if (!process.env.PINECONE_HOST) {
    console.error('PINECONE_HOST is not set in environment variables.');
    return null;
  }

  return pineconeClient.index({
    host: process.env.PINECONE_HOST,
    name: process.env.PINECONE_INDEX
  });
}

export async function upsertVectorStore(
  docs: Document[],
  conversationId: string
) {
  console.log('--- Starting upsertVectorStore process for Pinecone Serverless ---');
  const pineconeIndex = getPineconeIndex();
  if (!pineconeIndex) {
    console.error('Failed to get Pinecone index. Aborting upsert.');
    return;
  }

  try {
    console.log(`Processing ${docs.length} documents for conversation ID: ${conversationId}`);

    const records = docs.map((doc, i) => ({
      id: `${conversationId}-${Date.now()}-${i}`,
      values: [], // Will be generated by Pinecone
      metadata: {
        text: `${doc.role}: ${doc.content}`,
        role: doc.role,
        conversationId,
      },
    }));
    
    // For serverless, Pinecone expects the text to be in the metadata.
    // The vector is generated from the 'text' field in the metadata.
    // The actual embedding model is tied to the serverless index configuration.
    
    // The modern SDK uses `upsert` for both pod and serverless.
    // For serverless with a configured embedding model, you can upsert text in metadata
    // and Pinecone creates the vectors.
    
    // Let's create a text to embed from the documents
     const textsToEmbed = docs.map(doc => `${doc.role}: ${doc.content}`);

    console.log(`Attempting to upsert ${records.length} records to Pinecone index '${process.env.PINECONE_INDEX}'.`);
    
    // The current SDK does not have a direct `upsertRecords` that takes text.
    // The user's documentation seems to refer to a higher-level abstraction or a different version.
    // The standard way is to still generate embeddings client-side.
    // Let's re-add the embedding generation and use the standard `upsert`.
    // This seems to be the source of confusion.
    
    const { getEmbedding } = await import('@/services/embedding-client');

    const vectors = [];
    for (let i = 0; i < docs.length; i++) {
        const doc = docs[i];
        const docText = `${doc.role}: ${doc.content}`;
        const embedding = await getEmbedding(docText);

        if (!embedding || embedding.length === 0) {
            console.warn(`WARNING: Could not generate a valid embedding for doc: "${doc.content.substring(0, 50)}...". Skipping.`);
            continue;
        }

        vectors.push({
            id: `${conversationId}-${Date.now()}-${i}`,
            values: embedding,
            metadata: {
                text: doc.content, // Storing original content for retrieval
                role: doc.role,
                conversationId,
            },
        });
    }

    if(vectors.length > 0) {
      await pineconeIndex.upsert(vectors);
      console.log(`✅ SUCCESS: Successfully upserted ${vectors.length} documents to Pinecone.`);
    } else {
      console.log('No vectors were generated, nothing to upsert.');
    }


  } catch (error) {
    console.error('❌ CRITICAL: An error occurred during the Pinecone upsert process.', error);
  }
  console.log('--- Finished upsertVectorStore process ---');
}


export async function searchVectorStore(query: string, conversationId: string) {
  const pineconeIndex = getPineconeIndex();
  if (!pineconeIndex) {
    console.error('Skipping search because Pinecone is not configured.');
    return [];
  }

  try {
    const { getEmbedding } = await import('@/services/embedding-client');
    const queryEmbedding = await getEmbedding(query);

    if (!queryEmbedding) {
      console.error('Could not generate embedding for query.');
      return [];
    }

    const results = await pineconeIndex.query({
      vector: queryEmbedding,
      topK: TOP_K,
      filter: {
        conversationId: { $eq: conversationId },
      },
      includeMetadata: true,
    });

    return (
      results.matches?.map(match => ({
        pageContent: (match.metadata?.text as string) || '',
        score: match.score,
      })) || []
    );
  } catch (error) {
    console.error('Error searching Pinecone:', error);
    return [];
  }
}
